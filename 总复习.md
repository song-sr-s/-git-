# spi

spi有四根线，sck，miso，mosi，cs，因此是一个串行同步全双工的通信协议，它可以一主多从和i2c不一样i2c是多主多从，spi还有一个极性和相位的概念，极性控制是上升沿还是下降沿，相位控制是第一个边沿还是第二个边沿，
主机和从机要交换数据，牵涉到一个问题：主机在什么时刻输出数据到MOSI上而从机在什么时刻采样这个数据？

同步通信的一个特点就是所有数据的变化和采样都是伴随着时钟沿进行的，也就是说数据总是在时钟的边沿附近变化或被采样。而一个时钟周期必定包含了一个上升沿和一个下降沿，这是周期的定义所决定的，只是这两个沿的先后并无规定。

又因为数据从产生的时刻到它的稳定是需要一定时间的，那么，如果主机在上升沿输出数据到MOSI上，从机就只能在下降沿去采样这个数据了。反之如果一方在下降沿输出数据，那么另一方就必须在上升沿采样这个数据。

CPHA=1，就表示数据的输出是在一个时钟周期的第一个沿上，至于这个沿是上升沿还是下降沿，这要视CPOL的值而定，CPOL=1 那就是下降沿，反之就是上升沿。那么数据的采样自然就是在第二个沿上了。

CPHA=0，就表示数据的采样是在一个时钟周期的第一个沿上，同样它是什么沿由 CPOL 决定。那么数据的输出自然就在第二个沿上了。仔细想一下，这里会有一个问题：就是当一帧数据开始传输第一个 bit 时，在第一个时钟沿上就采样该数据了，那么它是在什么时候输出来的呢？有两种情况：一是 SSEL 使能的边沿，二是上一帧数据的最后一个时钟沿，有时两种情况还会同时生效。

# i2c

​	有两根线，scl时钟线和sda数据线，因此是一个串行同步半双工的通信协议，多主多从，
​	起始信号：当scl高电平时，sda由高到低
​	结束信号：当scl高电平时，sda由低到高
​	i2c时序：主机发送起始信号，发送8位数据，等待从机应答（ACK，低电平应答，高电平不应答）
​	数据有效性：scl高电平时，sda要保持稳定，scl为低电平时，sda才允许变化
​	写数据：一个字节的发数据从高到底发数据

	 	主设备给从设备发送/写入数据：
	1.主设备发送起始（START）信号
	2.主设备发送设备地址到从设备
	3.等待从设备响应(ACK)
	4.主设备发送数据到从设备，一般发送的每个字节数据后会跟着等待接收来自从设备的响应(ACK)
	5.数据发送完毕，主设备发送停止(STOP)信号终止传输
		主设备从从设备接收/读取数据
	1.设备发送起始（START）信号
	2.主设备发送设备地址到从设备
	3.等待从设备响应(ACK)
	4.主设备接收来自从设备的数据，一般接收的每个字节数据后会跟着向从设备发送一个响应(ACK)
	5.一般接收到最后一个数据后会发送一个无效响应(NACK)，然后主设备发送停止(STOP)信号终止传输

# uart串口通信

​	串口有两根线，TX,RX是一种异步全双工通信协议，一个数据流含起始位，有效数据位，奇偶校验位，停止位
​	起始位:低电平
​	数据位:可以设置5~8位
​	校验位:奇校验,偶校验,无校验,固定校验(固定奇校验,固定偶校验)
​	停止位:通常1位或2位
​	空闲:数据线为高电平
​	波特率:每秒传输的位数(发送端和接收端必须一样)
​	LSB:最低有效位(发送数据时先发送最低位)
​	MSB:最高有效位(发送数据时先发送最高位)

# usart串口通信

​	串口通讯有三根线,CLK, TX,RX是一种异步/同步全双工/半双工通信协议
​	UART与USART的区别
​	同步通信支持：USART支持同步通信，而UART仅支持异步通信。
​	时钟需求：USART需要一个时钟信号（CLK）来同步数据传输，而UART不需要外部时钟信号。UART的数据传输完全依赖于波特率的设定，而USART通过时钟信号来确保数据传输的同步。
​	数据传输速率：由于USART支持同步通信，因此在相同的波特率下，USART能够实现更高的数据传输速率。相比之下，UART的数据传输速率受限于异步通信的性质，通常较低。
​	硬件复杂性：USART相对于UART具有更复杂的硬件实现。由于支持同步通信和更高的数据传输速率，USART需要更多的硬件资源来实现时钟信号的生成和同步处理。UART的硬件实现相对简单，适用于一些低复杂性和低速率的应用。

配置串口
1.波特率：定义数据传输的速率
2.数据位宽：定义每个数据字节的位数通常是8位
3.停止位数：定义每个数据字节后的停止位书，通常是1位或2位
4.校验方式：定义数据的校验方式，可以无校验，奇校验或偶校验。

# AS608指纹模块

​	开始->录入图像->读取到指纹->生成指纹特征->搜索指纹->返回

# 存储器

**ROM**：只读存储器
**RAM**:   随机存取存储器
**随机**：是指数据不是线性以此存储，而是自由指定地址进行数据的读写

**存储器按存储介质分为**：易失忆型存储器和非易失忆型存储器
**易失忆型存储器**：RAM
**非易失忆型存储器**：ROM、FLASH、光盘、机械硬盘、软盘

**RAM**分为：DRAM（SDRAM、DDRSDRAM、DDRII SDRAM、DDRIII SDRAM）和SRAM

**DRAM**为:动态随机存取存储器（需要不断的刷新，才能保存数据）
**动态**：是指存储列阵需要不断的刷新来保证数据不丢失

**SRAM**为：静态随机存取存储器（利用双稳态电路进行存储即使有干扰对稳态电路也没有影响，所以有双稳态性）
**静态**：是指只要不掉电，存储在SRAM中的数据就可以一直保存，只要有电，SRAM中的数据就不会变化，加电情况下，不需要一直刷新，数据不会丢失

**SDRAM**：同步动态随机存储器，同步的DRAM,需要时钟（CLK）同步

**ROM**分为：MASK ROM和PROM(OTPROM、EPROM、EEPROM)

**EEPROM**:电可擦除存储器，EEPRM可以重复擦写，它的擦除和写入都是直接使用电路控制，不需要再使用外部设备来擦写，而且可以按字节单位修改数据，无需整个芯片擦除，现在主要使用的ROM芯片都是EEPROM**FLASH**分为：NOR FLASH和NAND FLASH

**FLASH**:非易失忆存储器，又叫**闪存**，掉电不丢失数据，容量大，价格便宜，容量比EEPROM大的多，擦除时，一般以多个字节为单位

***FLASH:存储器它结合了ROM和RAM的长处，不仅具备电子可擦除 可编程（EEPROM）的性能，还会断电丢失数据，同时可以快速读取**

**NOR FLASH**:NORFlash的读取和我们常见的SDRAM的读取是一样，用户可以直接运行装载在NORFLASH里面的代码，采取内存的随机读取技术

**NAND FLASH**:NAND 闪存的吨数单元测试采用串行结构，没有采取内存的随机读取技术，它的读取是取一块的形式来进行的，存储单元的读写是以页和块为单位来进行（一页包含若干字节，若干页则组成存储块，NAND 的存储块大小为8到32KB），这种结构最大的优点是在于容量可以做到很大，超过512MB容量的NAND产品行当普遍，NAND 闪存的成本较低，有利于规模普及

**DDR**：ddr是一个内存名称，意思即双倍速率同步动态随机存储器，是内存的其中一种

SDRAM在一个时钟周期内只传输一次数据，它是在时钟的上升期进行数据传输；**而DDR内存则是一个时钟周期内传输两次数据，它能够在时钟的上升期和下降期各传输一次数据，因此称为双倍速率同步动态随机存储器。**

DDR内存可以在与SDRAM相同的总线频率下达到更高的数据传输率。

DDR SDRAM 有多个内存条，提供多个隔行扫描的内存访问，从而提高内存带宽。内存条是一个内存阵列，两个内存条是两个内存阵列，四个内存条是四个内存阵列，

# **freertos**

**为什么每个任务都有自己的栈？**

因为每个任务都有自己的局部变量，都有自己的调用关系，保存现场保存自己的栈里。

**如何恢复现场？**

找到a的结构体，从结构体找到栈（sp栈顶值针），把栈里的值（先恢复R0-R15保存的值，最后恢复pc（下一段指令的地址））从栈里恢复到CPU里。



# static

这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：
1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。 

大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数 据和代码范围的好处和重要性。

# const

const的作用
1、对变量声明只读特性，保护变量值以防被修改。

2、节省空间，避免不必要的内存分配。const修饰的变量在程序运行过程中只有一份拷贝。

3、提高程序运行效率。编译器不为普通const常量分配存储空间，而是将他们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储和读取内存的操作

# volatile

使用volatile声明变量值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问



# 面试题

## 1.用指针将字符串“abcd”倒序成“dcba”

```
#include <stdio.h>  
#include <string.h>  
  
// 函数声明  
void reverseString(char *str);  
  
int main() {  
    char str[] = "abcd";  
    printf("原始字符串: %s\n", str);  
    reverseString(str);  
    printf("倒序后的字符串: %s\n", str);  
    return 0;  
}  
  
// 函数定义  
void reverseString(char *str) {  
    char *start = str; // 指向字符串开头  
    char *end = str + strlen(str) - 1; // 指向字符串末尾  
    char temp;  
  
    // 当start小于end时，执行循环  
    while (start < end) {  
        // 交换*start和*end的值  
        temp = *start;  
        *start = *end;  
        *end = temp;  
  
        // 移动指针  
        start++;  
        end--;  
    }  
}
```

## 2.冒泡排序

```
#include <stdio.h>  
  
// 冒泡排序函数  
void bubbleSort(int arr[], int n) {  
    int i, j, temp;  
    bool flag;
    for (i = 0; i < n-1; i++) {  
        // 最后的i个元素已经排好序，不需要再比较  
        for (j = 0; j < n-i-1; j++) {  
            if (arr[j] > arr[j+1]) {  
                // 交换 arr[j] 和 arr[j+1]  
                temp = arr[j];  
                arr[j] = arr[j+1];  
                arr[j+1] = temp; 
                flag = true;
            }  
        }  
        if(flag)
        {
        	flag = false;
        }
        else
        {
        	break;
        }
    }  
}  
  
// 打印数组的函数  
void printArray(int arr[], int size) {  
    int i;  
    for (i=0; i < size; i++)  
        printf("%d ", arr[i]);  
    printf("\n");  
}  
  
// 主函数，用于测试冒泡排序  
int main() {  
    int arr[] = {64, 34, 25, 12, 22, 11, 90};  
    int n = sizeof(arr)/sizeof(arr[0]);  
    bubbleSort(arr, n);  
    printf("Sorted array: \n");  
    printArray(arr, n);  
    return 0;  
}
```

**为什么sizeof不写在冒泡函数里？**

这是因为当你将数组作为参数传递给函数时，数组会退化为指向其第一个元素的指针，而 `sizeof` 一个指针只会给你指针本身的大小

# lvgl

## 一、free-rtos怎么移植?

1.下载Freertos源码
2.在工程里创建一个freertos文件夹，在freertos创建inc（放头文件），src（存源码），port（移植平台相关文件）文件夹
3.移植完最后在freertosconfig.h中加入中断的宏定义，去掉stm库函数的三个中断空函数

## 二、lvgl怎么移植?

1.下载lvgl源码
2.创建一个gui文件夹下面再创建一个lvgl文件夹
3.把源码下的example，src和lv_config_template.h,lvgl.h文件复制到lvgl文件下
3.把example文件下的文件名都去掉template后缀
4.使能文件名
5.添加自己的屏幕接口
6.添加自己的打点函数

## 三、谈一下你使用过的lvgl部件?

1.键盘
2.触摸屏
3.鼠标
4.按钮
5.标签
6.图片
7.列表
8.文本区域
9.图标

# ADC

ADC电路类型

并联比较型 优点：转换速率高     				缺点：功耗高，分辨率低			

逐次逼近型 优点：结构简单功耗低			 缺点：转换速率慢						特点：分辨率越高，采样速度越慢

并联比较型电路图：

![](C:\Users\86173\Desktop\总复习.pic\1.png)

逐次逼近型电路图：

![](C:\Users\86173\Desktop\总复习.pic\2.png)

ps：模拟电压和比较器电压遵循四舍五入

